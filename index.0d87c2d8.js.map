{"mappings":"CAAE,WASD,MAAMA,EAAa,CAClBC,QAAS,CACRC,mBAAsB,EACtBC,YAAe,IAEhBC,SAAU,CACTC,SAAY,CACXC,MAAO,MAERC,QAAW,CACVD,MAAO,MAERE,OAAU,CACTF,MAAO,MAERG,OAAU,CACTH,MAAO,MAERI,OAAU,CACTJ,MAAO,MAERK,WAAc,CACbL,MAAO,MAERM,UAAa,CACZN,MAAO,MAERO,WAAc,CACbP,MAAO,IAAIQ,MAAMC,SAElBC,uBAA0B,CACzBV,MAAO,IAAIQ,MAAMG,SAElBC,8BAAiC,CAChCZ,MAAO,IAAIQ,MAAMG,SAElBE,aAAgB,CACfb,MAAO,GAERc,YAAe,CACdd,MAAO,MAERe,YAAe,CACdf,MAAO,MAGTgB,aAEA,gKAWAC,eAEA,ouHA6HKC,EAAkB,CACvBvB,QAAS,CACRC,mBAAsB,GAEvBE,SAAU,CACTI,OAAU,CACTF,MAAO,MAERK,WAAc,CACbL,MAAO,MAERM,UAAa,CACZN,MAAO,OAGTgB,aAAc,sJAQdC,eAAgB,2rBAgCXE,EAAiB,CACtBrB,SAAU,CACTC,SAAY,CACXC,MAAO,MAERO,WAAc,CACbP,MAAO,IAAIQ,MAAMC,UAGnBO,aAAc,sJAQdC,eAAgB,igBA2BjBT,MAAMW,eAAiBA,EACvBX,MAAMU,gBAAkBA,EACxBV,MAAMd,WAAaA,CAEnB,CA1SC","sources":["../js/vendor/Three.js/r145/examples_js/shaders/SSAOShader.js"],"sourcesContent":["( function () {\n\n\t/**\n * References:\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n * https://learnopengl.com/Advanced-Lighting/SSAO\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n */\n\n\tconst SSAOShader = {\n\t\tdefines: {\n\t\t\t'PERSPECTIVE_CAMERA': 1,\n\t\t\t'KERNEL_SIZE': 32\n\t\t},\n\t\tuniforms: {\n\t\t\t'tDiffuse': {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\t'tNormal': {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\t'tDepth': {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\t'tNoise': {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\t'kernel': {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\t'cameraNear': {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\t'cameraFar': {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\t'resolution': {\n\t\t\t\tvalue: new THREE.Vector2()\n\t\t\t},\n\t\t\t'cameraProjectionMatrix': {\n\t\t\t\tvalue: new THREE.Matrix4()\n\t\t\t},\n\t\t\t'cameraInverseProjectionMatrix': {\n\t\t\t\tvalue: new THREE.Matrix4()\n\t\t\t},\n\t\t\t'kernelRadius': {\n\t\t\t\tvalue: 8\n\t\t\t},\n\t\t\t'minDistance': {\n\t\t\t\tvalue: 0.005\n\t\t\t},\n\t\t\t'maxDistance': {\n\t\t\t\tvalue: 0.05\n\t\t\t}\n\t\t},\n\t\tvertexShader:\n  /* glsl */\n  `\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\t\tfragmentShader:\n  /* glsl */\n  `\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tNormal;\n\t\tuniform sampler2D tDepth;\n\t\tuniform sampler2D tNoise;\n\n\t\tuniform vec3 kernel[ KERNEL_SIZE ];\n\n\t\tuniform vec2 resolution;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\n\t\tuniform float kernelRadius;\n\t\tuniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference\n\t\tuniform float maxDistance; // avoid the influence of fragments which are too far away\n\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tfloat getDepth( const in vec2 screenPosition ) {\n\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t}\n\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\n\t\t\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\n\t\t\tclipPosition *= clipW; // unprojection.\n\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n\n\t\t}\n\n\t\tvec3 getViewNormal( const in vec2 screenPosition ) {\n\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tfloat depth = getDepth( vUv );\n\t\t\tfloat viewZ = getViewZ( depth );\n\n\t\t\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\n\t\t\tvec3 viewNormal = getViewNormal( vUv );\n\n\t\t\tvec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\n\t\t\tvec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );\n\n\t\t\t// compute matrix used to reorient a kernel vector\n\n\t\t\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\n\t\t\tvec3 bitangent = cross( viewNormal, tangent );\n\t\t\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\n\n\t\t float occlusion = 0.0;\n\n\t\t for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\n\n\t\t\t\tvec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space\n\t\t\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point\n\n\t\t\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC\n\t\t\t\tsamplePointNDC /= samplePointNDC.w;\n\n\t\t\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates\n\n\t\t\t\tfloat realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture\n\t\t\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value\n\t\t\t\tfloat delta = sampleDepth - realDepth;\n\n\t\t\t\tif ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion\n\n\t\t\t\t\tocclusion += 1.0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\n\n\t\t\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\n\n\t\t}`\n\t};\n\tconst SSAODepthShader = {\n\t\tdefines: {\n\t\t\t'PERSPECTIVE_CAMERA': 1\n\t\t},\n\t\tuniforms: {\n\t\t\t'tDepth': {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\t'cameraNear': {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\t'cameraFar': {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tvertexShader: `varying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\t\tfragmentShader: `uniform sampler2D tDepth;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tfloat depth = getLinearDepth( vUv );\n\t\t\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\n\n\t\t}`\n\t};\n\tconst SSAOBlurShader = {\n\t\tuniforms: {\n\t\t\t'tDiffuse': {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\t'resolution': {\n\t\t\t\tvalue: new THREE.Vector2()\n\t\t\t}\n\t\t},\n\t\tvertexShader: `varying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\t\tfragmentShader: `uniform sampler2D tDiffuse;\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec2 texelSize = ( 1.0 / resolution );\n\t\t\tfloat result = 0.0;\n\n\t\t\tfor ( int i = - 2; i <= 2; i ++ ) {\n\n\t\t\t\tfor ( int j = - 2; j <= 2; j ++ ) {\n\n\t\t\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\n\t\t\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\n\n\t\t}`\n\t};\n\n\tTHREE.SSAOBlurShader = SSAOBlurShader;\n\tTHREE.SSAODepthShader = SSAODepthShader;\n\tTHREE.SSAOShader = SSAOShader;\n\n} )();\n"],"names":["SSAOShader","defines","PERSPECTIVE_CAMERA","KERNEL_SIZE","uniforms","tDiffuse","value","tNormal","tDepth","tNoise","kernel","cameraNear","cameraFar","resolution","THREE","Vector2","cameraProjectionMatrix","Matrix4","cameraInverseProjectionMatrix","kernelRadius","minDistance","maxDistance","vertexShader","fragmentShader","SSAODepthShader","SSAOBlurShader"],"version":3,"file":"index.0d87c2d8.js.map"}